#include "embed_asset.h"
#include "engine/file_system.h"
#include "utility/string_utils.h"
#include "assets/texture.h"
#include "core/ds_log.h"
#include <iomanip>
#include <sstream>
#include <string_view>
#include <unordered_map>
#include <filesystem>

namespace diverse
{
    void embed_texture(const std::string& texFilePath, const std::string& outPath, const std::string& arrayName)
    {
        auto texture = asset::load_image(texFilePath);

        size_t psize = texture.data.size();
        std::ofstream file;
        file.open(outPath);
        file << "//Generated by diverse using " << texFilePath << std::endl;
        file << "static const uint32_t width_" << arrayName << " = " << texture.dimensions[0] << ";" << std::endl;
        file << "static const uint32_t height_" << arrayName << " = " << texture.dimensions[1] << ";" << std::endl;
        file << "static const std::vector<uint8_t> data_" << arrayName << " = {" << (int)texture.data[0];
        for(size_t i = 1; i < psize; ++i)
            file << "," << (int)texture.data[i];
        file << "};\n";
        file << "REGISTER_SHADER(" << arrayName << ");";
        file.close();

        DS_LOG_INFO("generate embed texture {} to {}", texFilePath, outPath);
    }

    void embed_shader(const std::string& shaderPath, const std::string& outPath)
    {
        uint8_t* data = reinterpret_cast<uint8_t*>(FileSystem::read_file(shaderPath));
        uint32_t size  = uint32_t(FileSystem::get_file_size(shaderPath));

        if(!data)
        {
            DS_LOG_WARN("Failed to load shader : {0}", shaderPath);
            return;
        }
        auto shaderPath2 = shaderPath;
        shaderPath2 = stringutility::back_slashes_2_slashes(shaderPath2);
        auto shaderName = stringutility::remove_file_extension(shaderPath2);
        shaderName = stringutility::remove_character(shaderName, '/');
        shaderName = stringutility::remove_character(shaderName, '.');
        shaderName = stringutility::remove_character(shaderName, '_');
        shaderName = stringutility::remove_character(shaderName, ':');
        shaderName = stringutility::remove_character(shaderName, '+');
        shaderName = stringutility::remove_character(shaderName, '-');
        std::ofstream file;
        file.open(outPath);
        file << "//Generated by diverse using " << shaderPath << std::endl;
        file << "static const std::vector<uint8_t> spirv_" << shaderName << " = {" << (int)data[0];
        for (size_t i = 1; i < size; ++i)
            file << "," << (int)data[i];
        file << "};\n";
        file << "REGISTER_SHADER(" << shaderName<< ");";
        file.close();

        DS_LOG_INFO("generate Shader {} to {}", shaderPath, outPath);
    }


struct EmbedTexture
{
    uint32_t width;
    uint32_t height;
    std::vector<uint8_t> data;
};
std::unordered_map<std::string, EmbedTexture> embeded_textures;
std::unordered_map<std::string, SharedPtr<asset::Texture>> embeded_asset_textures;
struct RegisterTexture
{
	RegisterTexture(const std::string& name, const EmbedTexture& data)
	{
		embeded_textures[name] = data;
	}
};
#define REGISTER_SHADER(name) RegisterTexture register_texture_##name(#name, {width_##name,height_##name,data_##name})
//#ifdef DS_PRODUCTION
#include "embeded/select_all.inl"
#include "embeded/select_inverse.inl"
#include "embeded/select_lock.inl"
#include "embeded/select_none.inl"
#include "embeded/select_unlock.inl"
#include "embeded/select_picker.inl"
#include "embeded/select_lasso.inl"
#include "embeded/select_poly.inl"
#include "embeded/select_sphere.inl"
#include "embeded/select_delete.inl"
#include "embeded/select_brush.inl"
#include "embeded/new.inl"
#include "embeded/open.inl"
#include "embeded/save.inl"
#include "embeded/export.inl"
#include "embeded/import.inl"
//#endif
    SharedPtr<asset::Texture> get_embed_texture(const std::string& texture_path)
    {
        //get name from path 
        auto textureName = std::filesystem::path(texture_path).filename().string();
        textureName = stringutility::remove_file_extension(textureName);
        std::replace(textureName.begin(), textureName.end(), '-', '_');
        if(embeded_textures.find(textureName) == embeded_textures.end())
        {
            if(embeded_asset_textures.find(texture_path) == embeded_asset_textures.end())
            { 
                DS_LOG_WARN("don't exist this embed texture {}", texture_path);
                embeded_asset_textures[texture_path] = createSharedPtr<asset::Texture>(texture_path);
            }
            return embeded_asset_textures[texture_path];
        }
        auto texture = embeded_textures[textureName];
        if(embeded_asset_textures.find(texture_path) == embeded_asset_textures.end())
        {
            auto icon = createSharedPtr<asset::Texture>(asset::RawImage{ PixelFormat::R8G8B8A8_UNorm, 
                            {texture.width, texture.height}, texture.data });
            embeded_asset_textures[texture_path] = icon;
        }
        return embeded_asset_textures[texture_path];
    }

    std::unordered_map<std::string, SharedPtr<asset::Texture>>& get_embeded_asset_textures()
    {
        return embeded_asset_textures;
    }
}