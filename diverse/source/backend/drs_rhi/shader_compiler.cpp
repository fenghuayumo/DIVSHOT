#include "precompile.h"
#include "shader_compiler.h"
#include "utility/string_utils.h"
#include "utility/file_utils.h"
#include <mutex>
#include <any>
#if defined(DS_PLATFORM_WINDOWS)
#define loadLibrary(name) LoadLibraryA(name)
#define getProcAddress(handle,name) GetProcAddress(handle, name)

#include <atlbase.h> // ComPtr
#include "dxcapi.h"
#include <d3dcompiler.h>
#else
#define __EMULATE_UUID
#include <dxc/dxcapi.h>
#define loadLibrary(name) dlopen(name, RTLD_NOW | RTLD_LOCAL);
#define getProcAddress(handle,name) dlsym(handle, name)
#endif
#include "utility/timer.h"
#include "utility/hash_utils.h"

#ifdef DS_PRODUCTION
std::unordered_map<std::string, std::vector<uint8_t>> embeded_shaders;
struct RegisterShader
{
	RegisterShader(const std::string& name, const std::vector<uint8_t>& data)
	{
		embeded_shaders[name] = data;
	}
};
#define REGISTER_SHADER(name) RegisterShader register_shader_##name(#name, spirv_##name)
#include "assets/embeded/embeded_shaders.hpp"

namespace diverse
{
	auto load_embed_shader(const std::string& shaderPath) -> std::vector<uint8_t>
	{
		auto shaderPath2 = shaderPath;
		shaderPath2 = stringutility::back_slashes_2_slashes(shaderPath2);
		auto shaderName = stringutility::remove_file_extension(shaderPath2);
		shaderName = stringutility::remove_character(shaderName, '/');
		shaderName = stringutility::remove_character(shaderName, '.');
		shaderName = stringutility::remove_character(shaderName, '_');
		shaderName = stringutility::remove_character(shaderName, ':');
		shaderName = stringutility::remove_character(shaderName, '+');
		shaderName = stringutility::remove_character(shaderName, '-');
		if (embeded_shaders.find(shaderName) != embeded_shaders.end())
		{
			return embeded_shaders[shaderName];
		}
		DS_LOG_ERROR("not found emebed shader {}", shaderName);
		return {};
	}

	void delete_embed_shaders(const std::string& outPath)
	{
		if (std::filesystem::exists(outPath))
			std::filesystem::remove_all(outPath);
	}
}
#endif

namespace diverse
{ 
	std::mutex shader_dump_mutex;
	std::unordered_map<std::string,bool> has_dumped;
	void dump_shader_with_append(const std::string& shaderPath, const std::string& outPath, const std::vector<uint8_t>& data)
    {
		std::lock_guard lock(shader_dump_mutex);
        auto size = data.size();
        if(data.empty())
        {
            DS_LOG_WARN("Failed to load shader : {0}", shaderPath);
            return;
        }
        auto shaderPath2 = shaderPath;
        shaderPath2 = stringutility::back_slashes_2_slashes(shaderPath2);
        auto shaderName = stringutility::remove_file_extension(shaderPath2);
        shaderName = stringutility::remove_character(shaderName, '/');
        shaderName = stringutility::remove_character(shaderName, '.');
        shaderName = stringutility::remove_character(shaderName, '_');
		shaderName = stringutility::remove_character(shaderName, ':');
		shaderName = stringutility::remove_character(shaderName, '+');
		shaderName = stringutility::remove_character(shaderName, '-');
		if (has_dumped.find(shaderName) != has_dumped.end() && has_dumped[shaderName]) return;
		has_dumped[shaderName] = true;

        std::ofstream file(outPath,std::ios_base::app);
		if (!file.is_open())
			file.close();
        file << "//Generated by diverse using " << shaderPath << std::endl;
        file << "static const std::vector<uint8_t> spirv_" << shaderName << " = {" << (int)data[0];
        for (size_t i = 1; i < size; ++i)
            file << "," << (int)data[i];
        file << "};\n";
        file << "REGISTER_SHADER(" << shaderName<< ");\n";
        file.close();
        DS_LOG_INFO("generate Shader {} to {}", shaderPath, outPath);
    }
	
	bool shader_compiler_init()
	{
		std::string content;
		if(!loadText("../../diverse/source/assets/embeded/embeded_shaders.hpp", content))
			return false;
		std::stringstream ss(content);
		std::string word;

		while (ss >> word) 
		{
			if (word.find("spirv_") != std::string::npos){
				has_dumped[word] = 1;
			}
		}
		return true;
	}
// #ifdef DS_PLATFORM_WINDOWS
	struct DxcBlobEncoding {
		CComPtr<IDxcBlobEncoding> inner;
	};
	struct DxcLibrary {
		CComPtr<IDxcLibrary> inner;

		auto create_blob_with_encoding_from_str(const std::string& text)->DxcBlobEncoding
		{
			CComPtr<IDxcBlobEncoding> blob;
			const u32 CPUTF8 = 65001; // UTF-8 translation
			inner->CreateBlobWithEncodingFromPinned(text.c_str(), text.length(), CPUTF8,&blob);

			return {blob};
		}

		auto get_blob_as_string(const DxcBlobEncoding& blob)->std::string
		{
			CComPtr<IDxcBlobEncoding>	blob_utf8;
			auto result = inner->GetBlobAsUtf8(blob.inner,&blob_utf8);

			auto data = static_cast<const char*>(blob_utf8->GetBufferPointer());
			auto size = blob_utf8->GetBufferSize();

			return std::string(data, size);
		}
	};
	struct DxcBlob {
		CComPtr<IDxcBlob> inner;

		//template<typename T>
		//auto as_slice() -> T*
		//{
		//	return static_cast<T*>(inner->GetBufferPointer());
		//}

		template<typename T>
		auto to_vec()->std::vector<T>
		{
			auto data = static_cast<T*>(inner->GetBufferPointer());
			auto size = (inner->GetBufferSize());
			std::vector<T> vec(size / sizeof(T));
			memcpy(vec.data(), data, size);
			return vec;
		}


	};
	struct DxcOperationResult {
		CComPtr<IDxcOperationResult> inner;

		auto get_status() ->HRESULT {
			HRESULT status = 0;
			inner->GetStatus(&status);
			return status;
		}

		auto get_result()-> DxcBlob
		{
			CComPtr<IDxcBlob> blob;
			inner->GetResult(&blob);
	
			return {blob};
		}

		auto get_error_buffer()-> DxcBlobEncoding
		{
			CComPtr<IDxcBlobEncoding> blob;
			inner->GetErrorBuffer(&blob);
			return { blob };
		}

	};

	struct DefaultIncludeHandler : public IDxcIncludeHandler
	{
		CComPtr<IDxcIncludeHandler> dxcIncludeHandler;

		HRESULT STDMETHODCALLTYPE LoadSource(
			_In_z_ LPCWSTR pFilename,                                 // Candidate filename.
			_COM_Outptr_result_maybenull_ IDxcBlob** ppIncludeSource  // Resultant source object for included file, nullptr if not found.
		) override
		{
			HRESULT hr = dxcIncludeHandler->LoadSource(pFilename, ppIncludeSource);
			if (SUCCEEDED(hr))
			{
				// loadText( string_convert(pFilename));
			}
			return hr;
		}
	#ifdef DS_PLATFORM_WINDOWS
		HRESULT STDMETHODCALLTYPE QueryInterface(
			/* [in] */ REFIID riid,
			/* [iid_is][out] */ _COM_Outptr_ void __RPC_FAR* __RPC_FAR* ppvObject) override
	#else
		HRESULT QueryInterface(REFIID riid, void **ppvObject) override
	#endif
		{
			return dxcIncludeHandler->QueryInterface(riid, ppvObject);
		}
		
		ULONG STDMETHODCALLTYPE AddRef(void) override
		{
			return 0;
		}
		ULONG STDMETHODCALLTYPE Release(void) override
		{
			return 0;
		}
	};

	struct DxcIncludeHandlerWrapper
	{
		std::vector<std::string> pinned;
		DxcLibrary&	libray;

		//auto load_source(const std::string& filename)
	};
	struct DxcCompiler 
	{
		CComPtr<IDxcCompiler2> inner;
		DxcLibrary	library;

		auto prep_defines(const std::vector<std::pair<std::string, std::string>>& defines, std::vector<std::pair<std::wstring,std::wstring >>& wide_defines, std::vector<DxcDefine>& dxc_defines)
		{
			for (auto& [name, value] : defines)
			{
				if (value.empty())
				{
					wide_defines.push_back({string_convert(name), L"1"});
				}
				else
				{
					wide_defines.push_back({ string_convert(name), string_convert(value)});
				}
			}

			for (auto& [name, value] : wide_defines)
			{
				dxc_defines.push_back({name.c_str(), value.c_str()});
			}
		}

		auto prep_args(const std::vector<const char*>& args,std::vector<std::wstring>& wide_args, std::vector<const wchar_t*>& dxc_agrs)
		{
			for (const auto& a : args)
			{
				wide_args.push_back(string_convert(a));
			}
			for (auto& a : wide_args)
			{
				dxc_agrs.push_back(a.c_str());
			}
		}

		auto compile(
			const DxcBlobEncoding& blob,
			const std::string& source_name,
			const char* entry_point,
			const char* target_profile,
			std::vector<const char*> args,
			IDxcIncludeHandler* include_handler,
			const std::vector<std::pair<std::string, std::string>>& defines)-> DxcOperationResult
		{
			std::vector<std::wstring> wide_args;
			std::vector<const wchar_t*> dx_args;
			prep_args(args, wide_args, dx_args);

			std::vector<std::pair<std::wstring, std::wstring>> wide_defines;
			std::vector<DxcDefine> dxc_defines;
			prep_defines(defines, wide_defines, dxc_defines);

			CComPtr<IDxcOperationResult> result;

			inner->Compile(blob.inner, 
				string_convert(source_name).c_str(), 
				string_convert(entry_point).c_str(),
				string_convert(target_profile).c_str(),
				dx_args.data(), dx_args.size(), dxc_defines.data(), dxc_defines.size(), include_handler,&result);

			return {result};
		}
	};

	struct Dxc
	{
		DxcCreateInstanceProc DxcCreateInstance = nullptr;
		CComPtr<IDxcUtils> dxcUtils;
		Dxc()
		{
#ifdef DS_PLATFORM_WINDOWS
#define LIBDXCOMPILER "dxcompiler.dll"
			HMODULE dxcompiler = loadLibrary(LIBDXCOMPILER);
#elif defined(DS_PLATFORM_LINUX)
#define LIBDXCOMPILER "libdxcompiler.so"
			HMODULE dxcompiler = loadLibrary("./" LIBDXCOMPILER);
#elif defined(DS_PLATFORM_MACOS)
#define LIBDXCOMPILER "libdxcompiler.dylib"
			HMODULE dxcompiler = loadLibrary(LIBDXCOMPILER);
#endif
			if (dxcompiler != nullptr)
			{
				DxcCreateInstance = (DxcCreateInstanceProc)getProcAddress(dxcompiler, "DxcCreateInstance");
				if (DxcCreateInstance != nullptr)
				{
					CComPtr<IDxcCompiler3> dxcCompiler;
					HRESULT hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxcCompiler));
					assert(SUCCEEDED(hr));
					CComPtr<IDxcVersionInfo> info;
					hr = dxcCompiler->QueryInterface(&info);
					assert(SUCCEEDED(hr));
					uint32_t minor = 0;
					uint32_t major = 0;
					hr = info->GetVersion(&major, &minor);
					assert(SUCCEEDED(hr));
					DS_LOG_INFO("shadercompiler: loaded " LIBDXCOMPILER " (version: " + std::to_string(major) + "." + std::to_string(minor) + ")");
				}
				HRESULT hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&dxcUtils));
				assert(SUCCEEDED(hr));
			}
			else
			{
				DS_LOG_ERROR("shadercompiler: could not load library {}", LIBDXCOMPILER);
#if defined(DS_PLATFORM_LINUX)
				DS_LOG_ERROR(dlerror()); // print dlopen() error detail: https://linux.die.net/man/3/dlerror
#endif // PLATFORM_LINUX
			}
		}

		auto create_compiler() ->DxcCompiler {
			CComPtr<IDxcCompiler2> dxcCompiler;
	
			auto hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxcCompiler));
			assert(SUCCEEDED(hr));

			return { dxcCompiler, create_library()};
		}

		auto create_library() -> DxcLibrary {
			CComPtr<IDxcLibrary> library;
			HRESULT hr = DxcCreateInstance(CLSID_DxcLibrary, IID_PPV_ARGS(&library));
			assert(SUCCEEDED(hr));
	
			return { library };
		}
		auto create_include_handler()-> DefaultIncludeHandler
		{
			CComPtr<IDxcIncludeHandler> dxcIncludeHandler;

			auto hr = dxcUtils->CreateDefaultIncludeHandler(&dxcIncludeHandler);
			assert(SUCCEEDED(hr));

			DefaultIncludeHandler handler;
			handler.dxcIncludeHandler = dxcIncludeHandler;
			return handler;
		}
	};
	
	auto compile_hlsl(
		const std::string& source_name,
		const std::string& shader_text,
		const char* entry_point,
		const char* target_profile,
		const std::vector<const char*>& args,
		const std::vector<std::pair<std::string, std::string>>& defines)-> std::pair<std::vector<uint8>, std::string>
	{
		Dxc dxc;
		auto compiler = dxc.create_compiler();
		auto library = dxc.create_library();

		auto blob = library.create_blob_with_encoding_from_str(shader_text);
		auto handler = dxc.create_include_handler();
		auto result = compiler.compile(
			blob,
			source_name,
			entry_point,
			target_profile,
			args,
			&handler,
			defines
			);

		auto compile_error = result.get_status();
		if( 0 == compile_error)
		{
			auto result_blob = result.get_result();
			return {result_blob.to_vec<uint8>(), ""};
		}
		else
		{
			auto error_blob = result.get_error_buffer();
			auto error_str = library.get_blob_as_string(error_blob);
			return {{}, error_str };
		}
	}

	auto compile_generic_shader_hlsl(
			const std::string& name, 
			const std::string& source, 
			i64 last_write_time, 
			const char* target_profile, 
			const std::vector<std::pair<std::string, std::string>>& defines,
			const std::string& entry_point) -> std::vector<uint8>
	{
		Timer timer;
		auto pname = std::filesystem::path(name).parent_path().filename();
		auto fname = pname / std::filesystem::path(name).filename();
		bool need_compile = false;
#ifdef DS_PRODUCTION
		need_compile = false;
#else
		auto meta_name = std::filesystem::path(name).replace_extension(".meta");
		if (std::filesystem::exists(meta_name))
		{
			std::ifstream   ff(meta_name, std::ios::binary);
			long long last_compile_time = 0;
			ff >> last_compile_time;
			//whether the file is modified
			need_compile  = last_write_time > last_compile_time;
			ff.close();
		}
		else 
			need_compile = true;
		if(need_compile)
		{
			//write file modify time to meta file
			std::ofstream file(meta_name, std::ios::binary);
			file << last_write_time;
			file.close();
		}
#endif
        auto install_path = getInstallDirectory();
		for (auto define : defines)
			fname += define.first + define.second;
#ifdef DS_PLATFORM_MACOS
        auto shader_cache_name = getExecutablePath() + "/cache/" + fname.string() + ".cached";
#else
		auto shader_cache_name = install_path + "/cache/" + fname.string() + ".cached";
#endif
#ifdef DS_PRODUCTION
		//extern auto load_embed_shader(const std::string & shaderPath) -> std::vector<uint8_t>;

		auto spv = load_embed_shader(fname.string() + ".cached");
		if( !spv.empty() ) return spv;
		else
		{
			DS_LOG_ERROR("loading shader {} error", shader_cache_name);
		}
#else
		if (std::filesystem::exists(shader_cache_name) && !need_compile)
		{
			std::vector<u8> spirv;
			size_t data_size = 0;
			if (readByteData(shader_cache_name, spirv, data_size) && data_size > 0)
			{
				DS_LOG_INFO("loading cached shader {} ", shader_cache_name);
				return spirv;
			}
			else
			{
				DS_LOG_ERROR("loading shader {} error", shader_cache_name);
			}
		}
#endif
		auto res = compile_hlsl(name, source, entry_point.c_str(), target_profile, { "-spirv",
			//"-enable-16bit-types",
			"-fspv-target-env=vulkan1.2",
			"-Wfor-redefinition",
			"-Ges"}, // strict mode}, 
			defines);

		DS_LOG_INFO("dxc took {} for {}", timer.GetElapsedS(), name);
		if (res.second.empty())
		{
			if (!std::filesystem::exists(std::filesystem::path(shader_cache_name).parent_path()))
				std::filesystem::create_directories(std::filesystem::path(shader_cache_name).parent_path());
			shader_dump_mutex.lock();
			writeData(shader_cache_name, res.first.data(), res.first.size());
			shader_dump_mutex.unlock();
			DS_LOG_INFO("write shader {} cache", shader_cache_name);

			return res.first;
		}
		DS_LOG_ERROR("compile {} error: {}", name,res.second);
		return {};
	}

	auto compile_generic_shader_hlsl(
			const std::string& name, 
			const std::vector<SourceChunk<std::string>>& source, 
			const char* target_profile, 
			const std::vector<std::pair<std::string, std::string>>& defines,
			const std::string& entry_point) -> std::vector<uint8>
	{
		std::string str_text;
		i64 last_write_time = 0;
		for(const auto& s : source)
		{
			str_text += s.source;
			last_write_time = std::max<i64>(last_write_time, s.last_write_time);
		}
		return compile_generic_shader_hlsl(name, str_text, last_write_time,target_profile,defines,entry_point);
	}

}
